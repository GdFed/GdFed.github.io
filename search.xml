<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[3D全景图片实现]]></title>
    <url>%2F2017%2F06%2F24%2F3D%E5%85%A8%E6%99%AF%E5%9B%BE%E7%89%87%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[准备科普全景图共分为三种： ①球面全景图 利用一张全景图围成一个球，自身位置位于球体内。由于图片是矩形，所以最上和最下的缝合处很明显就能够看得出来。 球面全景图是最接近人眼的构建模式，若利用多个立面构建，拼接方法繁琐，性能消耗高。 因此，本文介绍的是上述通过一张全景图构成的球面全景图。 ②立方体全景图 一个立方体，有六个面组成，所以就需要六张图片啦。自身的位置位于立方体中间。这也是最常见的全景图构建模式。 ③柱状全景图 这个则是前两种构建模式的结合版啦。 准备工作在浏览器中实现3D全景浏览开发，首先需要几样东西： ①支持WebGL和canvas的浏览器 ②Three.js 这里就不介绍这个插件了，所以阅读本文需要Three.js简单的基础 O(∩_∩)O~ 下载地址：https://github.com/mrdoob/three.js ③photo-sphere-viewer.js 这是基于Three.js开发的柱状全景图插件 下载地址：https://github.com/JeremyHeleine/Photo-Sphere-Viewer ④全景图 像上图那样的360度全景图，最好是左右能够完美拼接的，这样环顾时才自然。 现在也有能够生成全景图的工具，这里就不介绍啦。 全景图素材站点：http://www.tupian114.com/tupian/quanjing.html 初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;3D pic&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="VR模式"&gt; &lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src="./three.min.js"&gt;&lt;/script&gt;&lt;script src="./photo-sphere-viewer.min.js"&gt;&lt;/script&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; html, body &#123; width: 100%; height: 100%; &#125;&lt;/style&gt;&lt;script&gt; var PSV; init(); function init(rr) &#123; PSV = new PhotoSphereViewer(&#123; panorama: rr || './img/360.jpg', container: document.getElementById('container'), time_anim: false, navbar: true, anim_speed: '1rpm', size: &#123; width: '100%', height: '90%' &#125;, tilt_down_max: Math.PI / 7, tilt_up_max: Math.PI / 7 &#125;) &#125; document.querySelector("input[type=button]").onclick = function () &#123; // PSV.toggleDeviceOrientation(); // PSV.toggleAutorotate(); PSV.toggleStereo(); // PSV.toggleFullscreen(); &#125;&lt;/script&gt; 配置参数介绍 panorama：（必选）全景图的路径。 container：（必选）放置全景图的容器。 autoload：（默认为true）true为自动加载全景图，false为迟点加载全景图（通.过load方法）。 usexmpdata：（默认值为true）photo sphere viewer是否必须读入xmp数据，false为不必须。 cors_anonymous：（默认值为true）true为不能通过cookies获得用户 pano_size：（默认值为null）全景图的大小，是否裁切。 default_position：（默认值为0）定义默认位置，用户看见的第一个点，例如：{long: math.pi, lat: math.pi/2}。 min_fov：（默认值为30）观察的最小区域，单位degrees，在1-179之间。 max_fov：（默认值为90）观察的最大区域，单位degrees，在1-179之间。 allow_user_interactions：（默认值为true）设置为false，则禁止用户和全景图交互（导航条不可用）。 allow_scroll_to_zoom：（默认值为true）若设置为false，则用户不能通过鼠标滚动进行缩放图片。 tilt_up_max：（默认值为math.pi/2）向上倾斜的最大角度，单位radians。 tilt_down_max：（默认值为math.pi/2）向下倾斜的最大角度，单位radians。 min_longitude：（默认值为0）能够展示的最小经度。 max_longitude：（默认值为2PI）能够展示的最大维度。 zoome_level：（默认值为0）默认的缩放级别，值在0-100之间。 long_offset：（默认值为PI/360）mouse/touch移动时每像素经过的经度值。 lat_offset：（默认值为pi/180）mouse/touch移动时每像素经过的纬度值。 time_anim（默认值为2000）全景图在time_anim毫秒后会自动进行动画。（设置为false禁用它） reverse_anim：（默认值为true）当水平方向到达最大/最小的经度时，动画方向是否反转（仅仅是不能看到完整的圆）。 anim_speed：（默认值为2rpm）动画每秒/分钟多少的速度。 vertical_anim_speed：（默认值为2rpm）垂直方向的动画每秒/分钟多少的速度。 vertical_anim_target：（默认值为0）当自动旋转时的维度，默认为赤道。 navbar：（默认为false）显示导航条。 navbar_style：（默认值为false）导航条的样式。有效的属性： 1- backgroundColor：导航条背景色（默认值rgba(61, 61, 61, 0.5)）； 1- buttonsColor：按钮前景色（默认值 rgba(255, 255, 255, 0.7)）； 1- buttonBackgroundColor：按钮激活时的背景色（默认值 rgba(255, 255, 255, 0.1)）； 1- buttonsHeight：按钮高度，单位px（默认值 20）； 1- autorotateThickness：自动旋转图片的层（默认值 1）； 1- zoomRangeWidth：缩放游标的宽度，单位px（默认值 50）； 1- zoomRangeThickness：缩放游标的层（默认值 1）； 1- zoomRangeDisk：缩放游标的放大率，单位px（默认值 7）； 1- fullscreenRatio：全屏图标的比例（默认值 4/3）； 1- fullscreenThickneee：全屏图片的层，单位px（默认值 2） loading_msg：（默认值为Loading…）加载信息。 loading_img：（默认值 为null）loading图片的路径。 loading_html：（默认值 为null）html加载器（添加到容器中的元素或字符串）。 size：（默认值为null）全景图容器的最终尺寸，例如{width: 500, height: 300}。 onready：（默认值为null）全景图准备好并且第一张图片展示出来后的回调函数。 方法介绍 addAction()：添加事件（插件没有提供执行事件的方法，似乎是提供给插件内部使用的）。 fitToContainer()：调整全景图容器大小为指定大小。 getPosition()：获取坐标经纬度。 getPositionInDegrees()：获取经纬度度数。 getZoomLevel()：获取缩放级别。 load()：加载全景图（）。 moveTo(longitude, latitude)：根据经纬度移动到某一点。 rotate(dlong, dlat)：根据经纬度度数移动到某一点。 toggleAutorotate()：是否开启全景图自动旋转。 toggleDeviceOrientation()：是否开启重力感应方向控制。 toggleFullscreen()：是否开启全景图全屏。 toggleStereo()：是否开启立体效果（可用于WebVR哦）。 zoom(level)：设置缩放级别。 zoomIn()：放大。 zoomOut()：缩小。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>全景</tag>
        <tag>threejs</tag>
        <tag>photo-sphere-viewer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js自制多屏同步弹幕原理分析]]></title>
    <url>%2F2017%2F05%2F23%2F%E5%85%B3%E4%BA%8Ejs%E8%87%AA%E5%88%B6%E5%A4%9A%E5%B1%8F%E5%90%8C%E6%AD%A5%E5%BC%B9%E5%B9%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[jQuery 简洁版需求 输入框输入点击,生成随机样式的span span弹幕从右往左运动 实现输入框输入点击,生成随机样式的span 123456789101112131415161718//弹幕内容var barrageVal = $('input').val();//检测的弹屏宽度,用于后期运动距离var widthSize = $('.barrageShow').width();var rightVal = widthSize;//检测的弹屏高度,用于计算弹幕出现位置var heightSize = $('.barrageShow').height();//弹幕出现的随机位置var topVal = Math.random() * heightSize;//弹幕出现的随机颜色var colorSize = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f'];var colorVal = '#' + colorSize[Math.ceil(Math.random() * 16)] + colorSize[Math.ceil(Math.random() * 16)] + colorSize[Math.ceil(Math.random() * 16)] + colorSize[Math.ceil(Math.random() * 16)] + colorSize[ Math.ceil(Math.random() * 16)] + colorSize[Math.ceil(Math.random() * 16)];//弹幕出现的随机大小var fontsizeVal = Math.ceil(Math.random() * 20 + 12);//弹幕运动的随机速度var speedVal = Math.random() * 5000 + 10000; span弹幕从右往左运动 12345678910111213if (barrageVal.trim()) &#123; var dom = document.createElement('span'); document.querySelector('.barrageShow').appendChild(dom); $(dom).html(barrageVal) .css(&#123; color: colorVal, fontSize: fontsizeVal, top: topVal &#125;) .animate(&#123;right: rightVal&#125;, speedVal , function () &#123; $(dom).fadeOut(); &#125;);&#125; 缺陷只能实现无刷新弹幕 改进思路数据分离出来:前台获取的数据, 先保存到后台;前台要显示, 再从后台调取. JSON+Ajax版 实现简单同步需求 输入框输入点击,生成随机样式的span span数据给后台将数据保存后 前台调取后台数据信息,完成span弹幕从右往左运动 实现输入框输入点击,生成随机样式的span 12345//大同于第一版,其中添加//topPer为出现的随机高度比例(代替之前的直接给值,因为不同屏幕高度不同)//timeval为span弹幕创建时的时间戳(用于判断span的运动距离)var timeVal = new Date().getTime();var topPer = parseInt(Math.random() * heightSize) / heightSize; span数据给后台将数据保存后,并返回给前台 12345678910111213$.ajax(&#123; url: './data/getData.php', type: 'post', data: &#123; value: barrageVal, timetemp: timeVal, color: colorVal, fontSize: fontsizeVal, top: topPer, speed: speedVal &#125;, success: function (backData) &#123; console.log(backData);&#125; 123456789101112131415161718&lt;--对应的getData.php--&gt;&lt;?php $value = addslashes($_POST['value']); $timetemp = addslashes($_POST['timetemp']); $color = addslashes($_POST['color']); $fontSize = addslashes($_POST['fontSize']); $top = addslashes($_POST['top']); $speed = addslashes($_POST['speed']); $str = '['; $obj = chop(ltrim(file_get_contents('./backData/barrage.json'),"[,") ,"]"); file_put_contents('./backData/barrage.json',$obj); file_put_contents('./backData/barrage.json',',&#123;"value":"'.$value.'","timetemp":"'.$timetemp.'","color":"'.$color.'","fontSize":"'.$fontSize.'","top":"'.$top.'","speed":"'.$speed.'","wSize":"'.$wSize.'"&#125;',FILE_APPEND); $obj = ltrim(file_get_contents('./backData/barrage.json'),","); $str = $str.$obj; $str =$str.']'; file_put_contents('./backData/barrage.json',$str); echo 'success!'; ?&gt; 前台根据数据信息,完成span弹幕从右往左运动 其中一个思路要改变: 之前让每一个span弹幕自行animate运动;现在则是设置定时器, 让barrageShow上的span弹幕改变right定位, 来模拟运动. 123456789101112131415161718192021222324252627282930setInterval(function () &#123; $.ajax(&#123; url: './data/showData.php', data: &#123;&#125;, success: function (backData) &#123; //初始化 $('.barrageShow').html(''); var spanArr = JSON.parse(backData); var rightSize = $('.barrageShow').width(); var dom = []; for (var i = 0; i &lt; spanArr.length; i++) &#123; var topVal = spanArr[i].top * $('.barrageShow').height(); //当前时间减去获取弹幕点击时的时间则可以知道弹幕已经运动多久,再根据其速度就可以得到向左运动的位置 var rightVal = (new Date().getTime() - spanArr[i].timetemp) /spanArr[i].speed *rightSize - rightSize; //弹幕运动到最左侧的就可以直接跳出这一步,不往下执行了 if (rightVal &gt; rightSize) continue; dom[i] = document.createElement('span'); $('.barrageShow').append(dom[i]); $(dom[i]).html(spanArr[i].value).css(&#123; color: spanArr[i].color, fontSize: spanArr[i].fontSize, top: topVal, right: rightVal &#125;) &#125; &#125; &#125;) &#125;, 10); 1234&lt;--对应的showData.php--&gt;&lt;?php echo file_get_contents('./backData/barrage.json'); ?&gt; 缺陷能实现刷新数据不丢失但不能实现多屏同步效果 改进思路数据分离出来:之前保存在json文件中,改进为保存在MySQL数据库; 时间戳:这个概念非常重要,因为多屏同步, 每一个客户端的时间是不同的. 所以需要在加载网页的时候就要获取客户端的时间与服务器的时间来计算时间差;将每一个客户端的时间都转换为服务器的时间. 这样每一个客户端发出的请求就都是以服务器为标准, 看上去, 客户端发布一条span弹幕, 每一个打开页面的客户端都可以同步看见. Mysql+Ajax版 实现简单同步需求 输入框输入点击,生成随机样式的span span数据给后台将数据保存后 前台调取后台数据信息,完成span弹幕从右往左运动 实现增加时间差概念 123456789var cilentTime = new Date().getTime();var timeDif;$.ajax(&#123; url: './data/getCilentTime.php', data: &#123;&#125;, success: function (backData) &#123; timeDif = cilentTime - backData*1000; &#125;&#125;) 123456&lt;--对应的getCilentTime.php--&gt;&lt;?php date_default_timezone_set("Asia/Shanghai"); $now = time(); echo $now; ?&gt; 输入框输入点击,生成随机样式的span 12//大同于第二版//添加时间差12 span数据给后台将数据保存后,并返回给前台 1234567891011121314$.ajax(&#123; url: './data/getData.php', type: 'post', data: &#123; value: barrageVal, timetemp: timeVal, timeDif: timeDif, color: colorVal, fontSize: fontsizeVal, top: topPer, speed: speedVal &#125;, success: function (backData) &#123; console.log(backData);&#125; 123456789101112131415161718192021222324&lt;--对应的getData.php--&gt;&lt;?php include './sql_login.php'; $value = addslashes($_POST['value']); $timetemp = $_POST['timetemp']; $timeDif = $_POST['timeDif']; $color = addslashes($_POST['color']); $fontSize = $_POST['fontSize']; $topPer = $_POST['topPer']; $speed = $_POST['speed']; $sql="INSERT INTO barrage ( value, timetemp, timeDif, color, fontSize, topPer, speed, wSize, hSize) VALUES ('$value',$timetemp,$timeDif,'$color',$fontSize,$topPer,$speed,$wSize,$hSize)"; if (!mysql_query($sql,$con))&#123; die('Error: ' . mysql_error()); &#125; echo '&#123;"status":"ok"&#125;'; mysql_close($con) ?&gt; 前台根据数据信息,完成span弹幕从右往左运动 其中又一个思路要改变: 最之前让每一个span弹幕自行animate运动;第二版则是设置定时器, 让barrageShow上的span弹幕改变right定位, 来模拟运动;现在是让加载页面是执行第一版的逻辑; 之后barrageShow不断请求ajax数据, 有数据则添加到弹屏执行第一版的span弹幕逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var currentId = 0; setTimeout(show, 50);setInterval(add, 100);function show() &#123; var nowTime = new Date().getTime(); $.ajax(&#123; url: './data/showData.php', data: &#123; timeDif: timeDif, nowTime: nowTime, barrageId: currentId &#125;, success: function (backData) &#123; var spanArr = JSON.parse(backData)['list']; currentId = JSON.parse(backData)['lastId']; var rightSize = $('.swiper-container').width(); var heightSize = $('.swiper-container').height(); var dom = []; for (var i = 0; i &lt; spanArr.length; i++) &#123; var topVal = spanArr[i].topPer * heightSize; var rightVal = getRight(); dom[i] = document.createElement('span'); $('.barrageShow').append(dom[i]); $(dom[i]).html(spanArr[i].value).css(&#123; color: spanArr[i].color, fontSize: spanArr[i].fontSize + "px", top: topVal + "px", right: rightVal + "px" &#125;) .animate(&#123; right: rightSize + "px" &#125;, 10000);//根据每个客户端时间不同进行换算成与服务器的时间同步 function getRight() &#123; var timeXD = nowTime - timeDif + parseInt(spanArr[i].timeDif); return (timeXD - spanArr[i].timetemp) / spanArr[i].speed * rightSize - rightSize &#125; &#125; &#125; &#125;);&#125;function add() &#123; var nowTime = new Date().getTime(); $.ajax(&#123; url: './data/showData.php', data: &#123; timeDif: timeDif, nowTime: nowTime, barrageId: currentId &#125;, success: function (backData) &#123; var spanArr = JSON.parse(backData)['list']; currentId = JSON.parse(backData)['lastId']; var rightSize = $('.swiper-container').width(); var heightSize = $('.swiper-container').height(); var dom = []; for (var i = 0; i &lt; spanArr.length; i++) &#123; var topVal = spanArr[i].topPer * heightSize; dom[i] = document.createElement('span'); $('.barrageShow').append(dom[i]); $(dom[i]).html(spanArr[i].value).css(&#123; color: spanArr[i].color, fontSize: spanArr[i].fontSize + "px", top: topVal + "px", right: -rightSize + "px" &#125;) .animate(&#123; right: rightSize + "px" &#125;, 10000); &#125; &#125; &#125;);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;--对应的showData.php--&gt;include './sql_login.php';$now = $_GET['nowTime'];$timeDif = $_GET['timeDif'];$barrageId = $_GET['barrageId'];// 数据库查询语句$sql="select * from barrage where Id &gt; '$barrageId'";$result = mysql_query($sql);$list = array();// $total = 0;$lastId = $barrageId;// 获取数据while($row = mysql_fetch_array($result))&#123; $lastId = $row['Id']; //根据每个客户端时间不同进行换算成与服务器的时间同步 if($now - $timeDif + $row['timeDif'] - $row['timetemp'] &gt; 10000)continue; $item = array( 'barrageId' =&gt; $row['Id'], 'value' =&gt; $row['value'], 'timetemp' =&gt; $row['timetemp'], 'timeDif' =&gt; $row['timeDif'], 'color' =&gt; $row['color'], 'fontSize' =&gt; $row['fontSize'], 'topPer' =&gt; $row['topPer'], 'speed' =&gt; $row['speed'], 'wSize' =&gt; $row['wSize'], 'hSize' =&gt; $row['hSize'] ); array_push($list,$item); // $total = $row['total'];&#125;echo json_encode(array( // 'total'=&gt; intval($total), 'lastId'=&gt; $lastId, 'list'=&gt;$list));mysql_close($con); 总结关键点(得到的经验):\1. 时间戳概念要实现同步,必须找寻每个客户端的共同点作为参数对比,时间戳就是一个物理参数;刚开始以为客户端的时间将是同步的,但是忽略的他们之前是存在的误差(人为修改时间或本身误差),所以必须获取到这样的误差值,用来计算和服务器同步即可.2.运动的表象jQuery中的animate其实也是让元素一帧一帧的移动;第一版,让每一个弹幕以个人来运动,以span弹幕为参照物,每次刷新的实为span弹幕; 第二版则以弹屏为参照物,给弹屏里的每一个span弹幕设置定位,刷新弹屏,同时改变span弹幕的定位位置(同时也以时间戳为参考了);第三版,在页面加载时(或者刷新),获取此刻弹屏上出现有span弹幕位置,让其从各自位置开始以自身为参考运动,然后不断异步获取后台数据,如有符合条件的span被获取,则让其从弹屏最右侧位置开始以自身为参考运动.3.前后台交互在开发过程中,出现了span弹幕重复打印并运行的情况,检查前台逻辑没有问题,再检查后台PHP逻辑也没有问题,最后在浏览器控制台中检测到是以为数据请求及响应的时间过长,而js逻辑中刷新的频率较短,所以造成了重复打印多条. 原因: setInterval(add, 100);而下面的TTFB时长1.06s 解决过程: 往上一版进行测试,发现并没有造成TTFB过长,说明ajax异步时长不是影响,并且前台js逻辑也没有影响 那可能出在数据库上面,最后发现php连接数据库的时候使用了localhost,这样会进行DNS解析,会耗时,最后改为127.0.01果然解决了这个问题 需改进之处:已实现多屏同步弹屏,并且压力测试较为良好.但是,页面在不断进行setInterval操作,对浏览器消耗较大,需要进行缓存机制的处理;前、后台数据的交互太过频繁,需要优化数据交互逻辑;如真实放在互联网上运行,同步机制需要更加灵活,需加入负载均衡机制;待项目成熟应进行弹幕框架封装;… … 前端的坑还会继续一个个地去踩;在路上, 会一个一个把坑尽量看清楚些, 看透彻了,为了下一次快掉进去之前, 不抽自己嘴巴子, 而是昂首跨过去,“来哇,互相伤害哇”!]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es5(转载)]]></title>
    <url>%2F2017%2F05%2F15%2Fes5-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[用更合理的方式写 JavaScript 目录 类型 对象 数组 字符串 函数 属性 变量 提升 比较运算符 &amp; 等号 块 注释 空白 逗号 分号 类型转化 命名规则 存取器 构造函数 事件 模块 jQuery ECMAScript 5 兼容性 测试 性能 资源 谁在使用 翻译 JavaScript 风格指南说明 与我们讨论 JavaScript 贡献者 许可 类型 原始值: 存取直接作用于它自身。 string number boolean null undefined 123456var foo = 1;var bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 复杂类型: 存取时作用于它自身值的引用。 object array function 123456var foo = [1, 2];var bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆ 回到顶部 对象 使用直接量创建对象。 12345// badvar item = new Object();// goodvar item = &#123;&#125;; 不要使用保留字作为键名，它们在 IE8 下不工作。更多信息。 1234567891011// badvar superman = &#123; default: &#123; clark: 'kent' &#125;, private: true&#125;;// goodvar superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true&#125;; 使用同义词替换需要使用的保留字。 1234567891011121314// badvar superman = &#123; class: 'alien'&#125;;// badvar superman = &#123; klass: 'alien'&#125;;// goodvar superman = &#123; type: 'alien'&#125;; ⬆ 回到顶部 数组 使用直接量创建数组。 12345// badvar items = new Array();// goodvar items = []; 向数组增加元素时使用 Array#push 来替代直接赋值。 1var someStack = []; 123456// badsomeStack[someStack.length] = &apos;abracadabra&apos;;// goodsomeStack.push(&apos;abracadabra&apos;);​ 123456789101112131415- 当你需要拷贝数组时，使用 Array#slice。[jsPerf](http://jsperf.com/converting-arguments-to-an-array/7) ```javascript var len = items.length; var itemsCopy = []; var i; // bad for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]; &#125; // good itemsCopy = items.slice(); 使用 Array#slice 将类数组对象转换成数组。 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; ⬆ 回到顶部 字符串 使用单引号 &#39;&#39; 包裹字符串。 1234567891011// badvar name = "Bob Parr";// goodvar name = 'Bob Parr';// badvar fullName = "Bob " + this.lastName;// goodvar fullName = 'Bob ' + this.lastName; 超过 100 个字符的字符串应该使用连接符写成多行。 注：若过度使用，通过连接符连接的长字符串可能会影响性能。jsPerf &amp; 讨论. 12345678910111213// badvar errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';// badvar errorMessage = 'This is a super long error that was thrown because \of Batman. When you stop to think about how Batman had anything to do \with this, you would get nowhere \fast.';// goodvar errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; 程序化生成的字符串使用 Array#join 连接而不是使用连接符。尤其是 IE 下：jsPerf. 12345678910111213141516171819202122232425262728293031323334353637383940var items;var messages;var length;var i;messages = [&#123; state: 'success', message: 'This one worked.'&#125;, &#123; state: 'success', message: 'This one worked as well.'&#125;, &#123; state: 'error', message: 'This one did not work.'&#125;];length = messages.length;// badfunction inbox(messages) &#123; items = '&lt;ul&gt;'; for (i = 0; i &lt; length; i++) &#123; items += '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;'; &#125; return items + '&lt;/ul&gt;';&#125;// goodfunction inbox(messages) &#123; items = []; for (i = 0; i &lt; length; i++) &#123; // use direct assignment in this case because we're micro-optimizing. items[i] = '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;'; &#125; return '&lt;ul&gt;' + items.join('') + '&lt;/ul&gt;';&#125; ⬆ 回到顶部 函数 函数表达式： 1234567891011121314// 匿名函数表达式var anonymous = function() &#123; return true;&#125;;// 命名函数表达式var named = function named() &#123; return true;&#125;;// 立即调用的函数表达式（IIFE）(function () &#123; console.log('Welcome to the Internet. Please follow me.');&#125;()); 永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。 注： ECMA-262 把 块 定义为一组语句。函数声明不是语句。阅读对 ECMA-262 这个问题的说明。 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodvar test;if (currentUser) &#123; test = function test() &#123; console.log('Yup.'); &#125;;&#125; 永远不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; ⬆ 回到顶部 属性 使用 . 来访问对象的属性。 12345678910var luke = &#123; jedi: true, age: 28&#125;;// badvar isJedi = luke['jedi'];// goodvar isJedi = luke.jedi; 当通过变量访问属性时使用中括号 []。 12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp('jedi'); ⬆ 回到顶部 变量 总是使用 var 来声明变量。不这么做将导致产生全局变量。我们要避免污染全局命名空间。 12345// badsuperPower = new SuperPower();// goodvar superPower = new SuperPower(); 使用 var 声明每一个变量。这样做的好处是增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。 123456789101112131415// badvar items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// （跟上面的代码比较一下，看看哪里错了）var items = getItems(), goSportsTeam = true; dragonball = 'z';// goodvar items = getItems();var goSportsTeam = true;var dragonball = 'z'; 最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。 123456789101112131415161718// badvar i, len, dragonball, items = getItems(), goSportsTeam = true;// badvar i;var items = getItems();var dragonball;var goSportsTeam = true;var len;// goodvar items = getItems();var goSportsTeam = true;var dragonball;var length;var i; 在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// badfunction () &#123; test(); console.log('doing stuff..'); //..other stuff.. var name = getName(); if (name === 'test') &#123; return false; &#125; return name;&#125;// goodfunction () &#123; var name = getName(); test(); console.log('doing stuff..'); //..other stuff.. if (name === 'test') &#123; return false; &#125; return name;&#125;// bad - 不必要的函数调用function () &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; this.setFirstName(name); return true;&#125;// goodfunction () &#123; var name; if (!arguments.length) &#123; return false; &#125; name = getName(); this.setFirstName(name); return true;&#125; ⬆ 回到顶部 提升 变量声明会提升至作用域顶部，但赋值不会。 123456789101112131415161718// 我们知道这样不能正常工作（假设这里没有名为 notDefined 的全局变量）function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// 但由于变量声明提升的原因，在一个变量引用后再创建它的变量声明将可以正常工作。// 注：变量赋值为 `true` 不会提升。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 解释器会把变量声明提升到作用域顶部，意味着我们的例子将被重写成：function example() &#123; var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125; 匿名函数表达式会提升它们的变量名，但不会提升函数的赋值。 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () &#123; console.log('anonymous function expression'); &#125;;&#125; 命名函数表达式会提升变量名，但不会提升函数名或函数体。 12345678910111213141516171819202122function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// 当函数名跟变量名一样时，表现也是如此。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;&#125; 函数声明提升它们的名字和函数体。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; 了解更多信息在 JavaScript Scoping &amp; Hoisting by Ben Cherry. ⬆ 回到顶部 比较运算符 &amp; 等号 优先使用 === 和 !== 而不是 == 和 !=. 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true 字符串 如果是空字符串 &#39;&#39; 被计算为 false，否则为 true 1234if ([0]) &#123; // true // 一个数组就是一个对象，对象被计算为 true&#125; 使用快捷方式。 12345678910111213141516171819// badif (name !== '') &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 了解更多信息在 Truth Equality and JavaScript by Angus Croll. ⬆ 回到顶部 块 使用大括号包裹所有的多行代码块。 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction () &#123; return false; &#125;// goodfunction () &#123; return false;&#125; 如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; ⬆ 回到顶部 注释 使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。 123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。 12345678910111213141516171819202122232425// badvar active = true; // is current tab// good// is current tabvar active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this.type || 'no type'; return type;&#125;// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this.type || 'no type'; return type;&#125; 给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。 使用 // FIXME: 标注问题。 1234567function Calculator() &#123; // FIXME: shouldn't use a global here total = 0; return this;&#125; 使用 // TODO: 标注问题的解决方式。 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; ⬆ 回到顶部 空白 使用 2 个空格作为缩进。 1234567891011121314// badfunction () &#123;∙∙∙∙var name;&#125;// badfunction () &#123;∙var name;&#125;// goodfunction () &#123;∙∙var name;&#125; 在大括号前放一个空格。 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;);// gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;); 在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。 12345678910111213141516171819// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; 使用空格把运算符隔开。 12345// badvar x=y+5;// goodvar x = y + 5; 在文件末尾插入一个空行。 1234// bad(function (global) &#123; // ...stuff...&#125;)(this); 12345// bad(function (global) &#123; // ...stuff...&#125;)(this);↵↵ 1234// good(function (global) &#123; // ...stuff...&#125;)(this);↵ 在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。 12345678910111213141516171819202122232425262728293031323334// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodvar leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 在块末和新语句前插入空行。 1234567891011121314151617181920212223242526272829303132// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badvar obj = &#123; foo: function () &#123; &#125;, bar: function () &#123; &#125;&#125;;return obj;// goodvar obj = &#123; foo: function () &#123; &#125;, bar: function () &#123; &#125;&#125;;return obj; ⬆ 回到顶部 逗号 行首逗号: 不需要。 1234567891011121314151617181920212223242526272829// badvar story = [ once , upon , aTime];// goodvar story = [ once, upon, aTime];// badvar hero = &#123; firstName: 'Bob' , lastName: 'Parr' , heroName: 'Mr. Incredible' , superPower: 'strength'&#125;;// goodvar hero = &#123; firstName: 'Bob', lastName: 'Parr', heroName: 'Mr. Incredible', superPower: 'strength'&#125;; 额外的行末逗号：不需要。这样做会在 IE6/7 和 IE9 怪异模式下引起问题。同样，多余的逗号在某些 ES3 的实现里会增加数组的长度。在 ES5 中已经澄清了 (source)： Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this. 1234567891011121314151617181920212223​```javascript// badvar hero = &#123; firstName: &apos;Kevin&apos;, lastName: &apos;Flynn&apos;,&#125;;var heroes = [ &apos;Batman&apos;, &apos;Superman&apos;,];// goodvar hero = &#123; firstName: &apos;Kevin&apos;, lastName: &apos;Flynn&apos;&#125;;var heroes = [ &apos;Batman&apos;, &apos;Superman&apos;];​ 12345678910111213141516171819202122232425**[⬆ 回到顶部](#table-of-contents)**## &lt;a name=&quot;semicolons&quot;&gt;分号&lt;/a&gt;- **使用分号。** ```javascript // bad (function () &#123; var name = &apos;Skywalker&apos; return name &#125;)() // good (function () &#123; var name = &apos;Skywalker&apos;; return name; &#125;)(); // good (防止函数在两个 IIFE 合并时被当成一个参数 ;(function () &#123; var name = &apos;Skywalker&apos;; return name; &#125;)(); 了解更多. ⬆ 回到顶部 类型转换 在语句开始时执行类型转换。 字符串： 12345678910111213// =&gt; this.reviewScore = 9;// badvar totalScore = this.reviewScore + '';// goodvar totalScore = '' + this.reviewScore;// badvar totalScore = '' + this.reviewScore + ' total score';// goodvar totalScore = this.reviewScore + ' total score'; 使用 parseInt 转换数字时总是带上类型转换的基数。 12345678910111213141516171819var inputValue = '4';// badvar val = new Number(inputValue);// badvar val = +inputValue;// badvar val = inputValue &gt;&gt; 0;// badvar val = parseInt(inputValue);// goodvar val = Number(inputValue);// goodvar val = parseInt(inputValue, 10); 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。 1234567// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */var val = inputValue &gt;&gt; 0; 注： 小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数（source）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。讨论。最大的 32 位整数是 2,147,483,647： 1232147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647 布尔: 12345678910var age = 0;// badvar hasAge = new Boolean(age);// goodvar hasAge = Boolean(age);// goodvar hasAge = !!age; ⬆ 回到顶部 命名规则 避免单字母命名。命名应具备描述性。 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 使用驼峰式命名对象、函数和实例。 123456789// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;var o = &#123;&#125;;function c() &#123;&#125;// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 使用帕斯卡式命名构造函数或类。 1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: 'nope'&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: 'yup'&#125;); 不要使用下划线前/后缀。 为什么？JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。长话短说：如果你想要某处为「私有」，它必须不能是显式提出的。 123456789​```javascript// badthis.__firstName__ = &apos;Panda&apos;;this.firstName_ = &apos;Panda&apos;;this._firstName = &apos;Panda&apos;;// goodthis.firstName = &apos;Panda&apos;;​ 12345678910111213141516171819202122232425262728293031323334- 不要保存 `this` 的引用。使用 Function#bind。 ```javascript // bad function () &#123; var self = this; return function () &#123; console.log(self); &#125;; &#125; // bad function () &#123; var that = this; return function () &#123; console.log(that); &#125;; &#125; // bad function () &#123; var _this = this; return function () &#123; console.log(_this); &#125;; &#125; // good function () &#123; return function () &#123; console.log(this); &#125;.bind(this); &#125; 给函数命名。这在做堆栈轨迹时很有帮助。 123456789// badvar log = function (msg) &#123; console.log(msg);&#125;;// goodvar log = function log(msg) &#123; console.log(msg);&#125;; 注： IE8 及以下版本对命名函数表达式的处理有些怪异。了解更多信息到 http://kangax.github.io/nfe/。 如果你的文件导出一个类，你的文件名应该与类名完全相同。 123456789101112131415// file contentsclass CheckBox &#123; // ...&#125;module.exports = CheckBox;// in some other file// badvar CheckBox = require('./checkBox');// badvar CheckBox = require('./check_box');// goodvar CheckBox = require('./CheckBox'); ⬆ 回到顶部 存取器 属性的存取函数不是必须的。 如果你需要存取函数时使用 getVal() 和 setVal(&#39;hello&#39;)。 1234567891011// baddragon.age();// gooddragon.getAge();// baddragon.age(25);// gooddragon.setAge(25); 如果属性是布尔值，使用 isVal() 或 hasVal()。 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 创建 get() 和 set() 函数是可以的，但要保持一致。 12345678910111213function Jedi(options) &#123; options || (options = &#123;&#125;); var lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber);&#125;Jedi.prototype.set = function set(key, val) &#123; this[key] = val;&#125;;Jedi.prototype.get = function get(key) &#123; return this[key];&#125;; ⬆ 回到顶部 构造函数 给对象原型分配方法，而不是使用一个新对象覆盖原型。覆盖原型将导致继承出现问题：重设原型将覆盖原有原型！ 1234567891011121314151617181920212223function Jedi() &#123; console.log('new jedi');&#125;// badJedi.prototype = &#123; fight: function fight() &#123; console.log('fighting'); &#125;, block: function block() &#123; console.log('blocking'); &#125;&#125;;// goodJedi.prototype.fight = function fight() &#123; console.log('fighting');&#125;;Jedi.prototype.block = function block() &#123; console.log('blocking');&#125;; 方法可以返回 this 来实现方法链式使用。 1234567891011121314151617181920212223242526272829// badJedi.prototype.jump = function jump() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height;&#125;;var luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodJedi.prototype.jump = function jump() &#123; this.jumping = true; return this;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height; return this;&#125;;var luke = new Jedi();luke.jump() .setHeight(20); 写一个自定义的 toString() 方法是可以的，但是确保它可以正常工作且不会产生副作用。 123456789101112function Jedi(options) &#123; options || (options = &#123;&#125;); this.name = options.name || 'no name';&#125;Jedi.prototype.getName = function getName() &#123; return this.name;&#125;;Jedi.prototype.toString = function toString() &#123; return 'Jedi - ' + this.getName();&#125;; ⬆ 回到顶部 事件 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法： 12345678// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', function (e, listingId) &#123; // do something with listingId&#125;); 更好的写法： 12345678// good$(this).trigger('listingUpdated', &#123; listingId : listing.id &#125;);...$(this).on('listingUpdated', function (e, data) &#123; // do something with data.listingId&#125;); ⬆ 回到顶部 模块 模块应该以 ! 开始。这样确保了当一个不好的模块忘记包含最后的分号时，在合并代码到生产环境后不会产生错误。详细说明 文件应该以驼峰式命名，并放在同名的文件夹里，且与导出的名字一致。 增加一个名为 noConflict() 的方法来设置导出的模块为前一个版本并返回它。 永远在模块顶部声明 &#39;use strict&#39;;。 123456789101112131415161718// fancyInput/fancyInput.js!function (global) &#123; 'use strict'; var previousFancyInput = global.FancyInput; function FancyInput(options) &#123; this.options = options || &#123;&#125;; &#125; FancyInput.noConflict = function noConflict() &#123; global.FancyInput = previousFancyInput; return FancyInput; &#125;; global.FancyInput = FancyInput;&#125;(this); ⬆ 回到顶部 jQuery 使用 $ 作为存储 jQuery 对象的变量名前缀。 12345// badvar sidebar = $('.sidebar');// goodvar $sidebar = $('.sidebar'); 缓存 jQuery 查询。 12345678910111213141516171819202122// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; 对 DOM 查询使用层叠 $(&#39;.sidebar ul&#39;) 或 父元素 &gt; 子元素 $(&#39;.sidebar &gt; ul&#39;)。 jsPerf 对有作用域的 jQuery 对象查询使用 find。 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ⬆ 回到顶部 ECMAScript 5 兼容性 参考 Kangax 的 ES5 兼容表. ⬆ 回到顶部 测试 Yup. 123function () &#123; return true;&#125; ⬆ 回到顶部 性能 On Layout &amp; Web Performance String vs Array Concat Try/Catch Cost In a Loop Bang Function jQuery Find vs Context, Selector innerHTML vs textContent for script text Long String Concatenation Loading… ⬆ 回到顶部 资源推荐阅读 Annotated ECMAScript 5.1 工具 Code Style Linters JSHint - Airbnb Style .jshintrc JSCS - Airbnb Style Preset 其它风格指南 Google JavaScript Style Guide jQuery Core Style Guidelines Principles of Writing Consistent, Idiomatic JavaScript JavaScript Standard Style 其它风格 Naming this in nested functions - Christian Johansen Conditional Callbacks - Ross Allen Popular JavaScript Coding Conventions on Github - JeongHoon Byun Multiple var statements in JavaScript, not superfluous - Ben Alman 进一步阅读 Understanding JavaScript Closures - Angus Croll Basic JavaScript for the impatient programmer - Dr. Axel Rauschmayer You Might Not Need jQuery - Zack Bloom &amp; Adam Schwartz ES6 Features - Luke Hoban Frontend Guidelines - Benjamin De Cock 书籍 JavaScript: The Good Parts - Douglas Crockford JavaScript Patterns - Stoyan Stefanov Pro JavaScript Design Patterns - Ross Harmes and Dustin Diaz High Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders Maintainable JavaScript - Nicholas C. Zakas JavaScript Web Applications - Alex MacCaw Pro JavaScript Techniques - John Resig Smashing Node.js: JavaScript Everywhere - Guillermo Rauch Secrets of the JavaScript Ninja - John Resig and Bear Bibeault Human JavaScript - Henrik Joreteg Superhero.js - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy JSBooks - Julien Bouquillon Third Party JavaScript - Ben Vinegar and Anton Kovalyov Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman Eloquent JavaScript - Marijn Haverbeke You Don’t Know JS - Kyle Simpson 博客 DailyJS JavaScript Weekly JavaScript, JavaScript… Bocoup Weblog Adequately Good NCZOnline Perfection Kills Ben Alman Dmitry Baranovskiy Dustin Diaz nettuts 播客 JavaScript Jabber ⬆ 回到顶部 谁在使用 这是一个使用本风格指南的组织列表。给我们发 pull request 或开一个 issue 让我们将你增加到列表上。 Aan Zee: AanZee/javascript Adult Swim: adult-swim/javascript Airbnb: airbnb/javascript Apartmint: apartmint/javascript Avalara: avalara/javascript Billabong: billabong/javascript Compass Learning: compasslearning/javascript-style-guide DailyMotion: dailymotion/javascript Digitpaint digitpaint/javascript Evernote: evernote/javascript-style-guide ExactTarget: ExactTarget/javascript Flexberry: Flexberry/javascript-style-guide Gawker Media: gawkermedia/javascript General Electric: GeneralElectric/javascript GoodData: gooddata/gdc-js-style Grooveshark: grooveshark/javascript How About We: howaboutwe/javascript InfoJobs: InfoJobs/JavaScript-Style-Guide Intent Media: intentmedia/javascript Jam3: Jam3/Javascript-Code-Conventions JSSolutions: JSSolutions/javascript Kinetica Solutions: kinetica/javascript Mighty Spring: mightyspring/javascript MinnPost: MinnPost/javascript ModCloth: modcloth/javascript Money Advice Service: moneyadviceservice/javascript Muber: muber/javascript National Geographic: natgeo/javascript National Park Service: nationalparkservice/javascript Nimbl3: nimbl3/javascript Nordic Venture Family: CodeDistillery/javascript Orion Health: orionhealth/javascript Peerby: Peerby/javascript Razorfish: razorfish/javascript-style-guide reddit: reddit/styleguide/javascript REI: reidev/js-style-guide Ripple: ripple/javascript-style-guide SeekingAlpha: seekingalpha/javascript-style-guide Shutterfly: shutterfly/javascript StudentSphere: studentsphere/javascript Super: SuperJobs/javascript SysGarage: sysgarage/javascript-style-guide Target: target/javascript TheLadders: TheLadders/javascript T4R Technology: T4R-Technology/javascript VoxFeed: VoxFeed/javascript-style-guide Weggo: Weggo/javascript Zillow: zillow/javascript ZocDoc: ZocDoc/javascript 翻译 这份风格指南也提供了其它语言的版本： Brazilian Portuguese: armoucar/javascript-style-guide Bulgarian: borislavvv/javascript Catalan: fpmweb/javascript-style-guide Chinese(Traditional): jigsawye/javascript Chinese(Simplified): sivan/javascript French: nmussy/javascript-style-guide German: timofurrer/javascript-style-guide Italian: sinkswim/javascript-style-guide Japanese: mitsuruog/javacript-style-guide Korean: tipjs/javascript-style-guide Polish: mjurczyk/javascript Russian: uprock/javascript Spanish: paolocarrasco/javascript-style-guide Thai: lvarayut/javascript-style-guide JavaScript 风格指南说明 Reference 与我们讨论 JavaScript Find us on gitter. 贡献者 View Contributors 许可(The MIT License) Copyright (c) 2014 Airbnb Permission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the‘Software’), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions: The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ⬆ 回到顶部]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单封装template]]></title>
    <url>%2F2017%2F04%2F25%2F%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85templatejs%2F</url>
    <content type="text"><![CDATA[简单封装template1.先来一个例子: 123456&lt;script type="text/html" id="template"&gt;&lt;ul&gt; &lt;li&gt;'&#123;&#123;'name'&#125;&#125;'&lt;/li&gt; &lt;li&gt;'&#123;&#123;'skill'&#125;&#125;'&lt;/li&gt;&lt;/ul&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829&lt;script&gt;var data = &#123; name: 'jack', skill: 'jump'&#125;;var templateDom = document.getElementById('template');var string = templateDom.innerHTML;var reg = /'&#123;&#123;'(\w+)'&#125;&#125;'/;var result = reg.exec(string);while (result) &#123;string = string.replace(result[0],data[result[1]]);result = reg.exec(string);&#125;document.body.innerHTML = string;&lt;/script&gt; 结果: jack jump 2.进行函数封装: 123456789101112131415161718192021function template(id,data) &#123;var templateDom =document.getElementById(id);var string =templateDom.innerHTML;var reg = /'&#123;&#123;'(\w+)'&#125;&#125;'/;var result =reg.exec(string);while (result) &#123;string = string.replace(result[0],data[result[1]]);result = reg.exec(string);&#125;return string;&#125; 进行调用一下: 1234567document.body.innerHTML =template('template', &#123;name: 'rose',skill: 'beautiful'&#125;); 结果: rose beautiful 3.注意事项: 1234567891011&lt;script type="text/html" id="template"&gt;&lt;ul&gt;&lt;li&gt;'&#123;&#123;'name'&#125;&#125;'&lt;/li&gt;&lt;li&gt;'&#123;&#123;'skill'&#125;&#125;'&lt;/li&gt;&lt;/ul&gt;&lt;/script&gt; a.上面”‘‘“里面的内容要根据data的key来设置; b.type只要不为text/javaScript,html可以换成其他的名字,如test,但设置为html,编辑器可实现代码自动提示以及高亮的效果; c.必须给定一个id(id具有唯一性),调用函数时通过id获取对应作用元素. 12345var reg = /'&#123;&#123;'(\w+)'&#125;&#125;'/;var result = reg.exec(string);console.log(result); d.打印出来的result注意理解(正则表达式exec方法); 4.大神做的template可见:https://aui.github.io/art-template/docs/]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery瀑布流技术封装并制定插件]]></title>
    <url>%2F2017%2F04%2F12%2FjQuery%E7%80%91%E5%B8%83%E6%B5%81%E6%8A%80%E6%9C%AF%E5%B0%81%E8%A3%85%E5%B9%B6%E5%88%B6%E5%AE%9A%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[瀑布流布局,其实是一种绝对定位(absolute)布局. 原理分析: 1.html,css结构 : 子绝父相 123456789101112131415&lt;body&gt;&lt;div class="items"&gt;&lt;div class="item"&gt;&lt;/div&gt;&lt;div class="item"&gt;&lt;/div&gt;&lt;div class="item"&gt;&lt;/div&gt;...&lt;/div&gt;&lt;/body&gt; 2.给每一个子元素进行top,left设置定位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171/*需求1:设置原始数据一排元素个数n : items的宽度/item的宽度 向下取整间隙margin: (items的宽度-n*item的宽度)/(n+1)一排元素的总高度集合topArr: 长度为n 元素为对应item的高度 初始值都为margin需求2:设置第一排dom元素位置需求2.1:修改topArr里面元素的值*/var itemWidth = $('.item').width();var n =Math.floor($('.items').width() /itemWidth);var margin = ($('.items').width() -n *itemWidth) / (n +1);var topArr = [];for (vari =0;i &lt; n; i++) &#123;topArr[i] =margin;$('.item').eq(i).css(&#123;top: topArr[i],left: (margin +itemWidth) *i +margin&#125;);topArr[i] +=$('.item').eq(i).height();&#125;/*需求3:判断topArr中最小值及index,依次将后面的item元素放在其后面需求3.1:每次放置后,修改topArr里面元素的值*/for (vari =n;i &lt; $('.item').length;i++) &#123;var minH =Infinity;var minIndex = -1;for (varj =0;j &lt; n; j++) &#123;if (topArr[j] &lt;minH) &#123;minH = topArr[j];minIndex = j;&#125;&#125;$('.item').eq(i).css(&#123;top: minH,left: (margin +itemWidth) *minIndex +margin&#125;);topArr[minIndex] +=$('.item').eq(i).height();&#125;/需求4:设置父容器高度/var maxH = -Infinity;for(vari=0;i&lt;n;i++)&#123;if(topArr[i]&gt;maxH)&#123;maxH = topArr[i];&#125;&#125;$('.items').height(maxH);$.fn.extend(&#123;waterfall: function () &#123;/this指向调用该函数的jQuery对象/var itemWidth =this.children().width();var n =Math.floor(this.width() /itemWidth);var margin = (this.width() -n *itemWidth) / (n +1);var topArr = [];for (vari =0;i &lt; n; i++) &#123;topArr[i] =margin;this.children().eq(i).css(&#123;top: topArr[i],left: (margin +itemWidth) *i +margin&#125;);topArr[i] +=this.children().eq(i).height();&#125;for (vari =n;i &lt; this.children().length;i++) &#123;var minH =Infinity;var minIndex = -1;for (varj =0;j &lt; n; j++) &#123;if (topArr[j] &lt;minH) &#123;minH = topArr[j];minIndex = j;&#125;&#125;this.children().eq(i).css(&#123;top: minH,left: (margin +itemWidth) *minIndex +margin&#125;);topArr[minIndex] +=this.children().eq(i).height();&#125;var maxH = -Infinity;for(vari=0;i&lt;n;i++)&#123;if(topArr[i]&gt;maxH)&#123;maxH = topArr[i];&#125;&#125;this.height(maxH);/返回this,也是jQuery链式编程的逻辑/return this;&#125;&#125;)$('.items').waterfall(); 3.添加浏览器缩放事件 12345$(window).resize(function () &#123;$('.items').waterfall();&#125;);]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js模拟jQuery对象调用click事件理解this和$(this)]]></title>
    <url>%2F2017%2F03%2F25%2F%E5%8E%9F%E7%94%9Fjs%E6%A8%A1%E6%8B%9FjQuery%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8click%E4%BA%8B%E4%BB%B6%E7%90%86%E8%A7%A3this%2F</url>
    <content type="text"><![CDATA[原生js中,this指向调用的dom元素;jQuery中,事件回调函数中的this也指向dom元素,所以在回调函数中$(this)才是指向jQuery的对象.这个要和jQuery中插件创建里面的this进行区分,里面的this则指向调用对象,即jQuery对象.之前一直对这个不理解,所以现在通过一个例子来进行自己的理解分析:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;script&gt;var bodyDom = document.querySelector('body');/*bodyDom.onclick = function () &#123;console.log('我是Dom事件');&#125;;*/bodyDom.addEventListener('click',function()&#123;console.log('我是Dom事件');&#125;)function $(ele)&#123;var dom = null;if(typeof ele == 'object')&#123;dom =ele;&#125;else&#123;dom = document.querySelector(ele);&#125;var objDom = &#123;0:dom,length:1&#125;;objDom.click =function(fn)&#123;for (vari = 0; i &lt; objDom.length;i++) &#123;var element = objDom[i];element.addEventListener("click",fn); &#125;&#125;;return objDom;&#125; $('body').click(function () &#123;console.log('我是$封装事件');console.log(this);console.log($(this));&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2017%2F01%2F14%2FGit%2F</url>
    <content type="text"><![CDATA[版本控制工具源代码管理工具(版本控制)的好处a、利于团队开发 b、对于个人开发 1--&gt;对某个功能的修改操作 版本控制工具的种类 git(github) svn java：maven .net：vss tfs 源代码管理工具按照功能划分a、本地代码管理 –&gt;用于个人开发 –&gt;被淘汰b、集中式源代码管理工具(svn)c、分布式。。。。。。。(git) –&gt;兼具了a+b的功能 Git的使用git init 将当前文件夹进行初始化1--&gt;一定要明确你要将哪个文件夹被git管理起来 git status 可以查看仓库中的文件状态 在往git仓库中添加文件的时候，这些刚添加的文件，状态是：未追踪(Untracked) 对于已经进入过暂存区的文件，文件的状态是：to be committed 对于已经进入过暂存区的文件，再次修改文件，文件的状态是：modified –&gt;如果当前文件夹下面的某个文件夹是空的，不会显示在结果中 git add 文件名–&gt;将指定的文件放到暂存区把文件放到暂存区之后，状态是：待提交(changes to be committed) 1git add *.后缀名 把指定后缀名的所有文件提交暂存区 –&gt;git add 命令不仅仅可以将新添加的文件放到暂存区，也可以将已修改的文件放到暂存区 git add 指定目录–&gt;将指定目录下面的文件放到暂存区1如果当前仓库的根目录（.git文件夹位于的目录） git add .将仓库下面的没有被提交到暂存区的代码放到暂存区 git add . –&gt;将当前仓库中的所有的没有被提交到暂存区的代码放到暂存区 git commit 提交本地仓库12git commit 会要求填写提交信息git commit -m &quot;this is first commit&quot; 直接带信息提交(可以不带引号,但信息必须没有空格) git log 查看日志1git log --oneline 查看日志简略信息 关于用户名和邮箱的配置–&gt;如果从来没有过，在提交到本地主仓库之前不会有任何问题，但是git commit -m 都会提示你没有配置过，如果没有配置过，是无法正常提交代码，报错信息：Please tell me who you are 123456789git config --global user.name xxx 设置用户名git config --globa user.email xxx@xx.com 设置用户邮箱git config --global user.name 查看用户名git config --globa user.email 查看用户邮箱--&gt;可以通过--global选项实现在本机一次配置多次使用 git push 服务器仓库地址 master–&gt;将本地主仓库中的代码上传到服务器中 git clone 服务器仓库地址–&gt;将服务器代码克隆到本地 1git clone 服务器仓库地址 apphome 修改仓库名为apphome git pull 服务器仓库地址 master –&gt;将服务器代码更新到本地(关联) 说明：a、只有文件夹中有.git文件夹，仓库就一直有效，–&gt;一旦把.git文件夹删除，那么仓库就废了b、git会忽略所有的空文件夹c、git管理的文件，不要轻易重命名文件 1--&gt;1.txt--&gt;2.txt这样的重命名操作将会被识别为：删除了1.txt，创建了2.txt 2个场景服务器仓库是空仓库12345git inittouch 1.txtgit add 1.txtgit commit -m 提交了1.txtgit push 服务器仓库地址 master 服务器仓库是非空仓库(☆☆☆工作中更常见☆☆☆)123456git initgit pull 服务器仓库地址 mastertouch 2.txtgit add 2.txtgit commit -m 创建了2.txtgit push 服务器仓库地址 master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash常见命令]]></title>
    <url>%2F2017%2F01%2F03%2Fbash%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[shell（壳） shell其实它是操作系统内核和用户之间的一个纽带(桥梁) 用户操作shell，shell操作操作系统内核，操作系统内核操作计算机硬件 shell的种类： 命令行shell windows: cmd powershell mac os : 终端(terminal) linux: sh bash 图形化shell windows操作系统 mac os linux–&gt;ubuntu等 clear 清屏Ctrl + C 或者 Q 阻止进程pwd(print working directory)打印出当前目录(文件夹)路径的全名称 1pwd 例如当前位于桌面：c:/users/用户名/desktop ls(list)列举出当前目录（文件夹）下面的所有的直接子文件和子文件夹 --&gt;列举出来的文件夹名称有/结尾的，但是文件没有/结尾的 列举任意目录下面的所有的子文件和文件夹 ls 指定目录路径 ls -l 列举出来的文件和文件夹包含了文件的创建者/创建时间等信息 1ls -a 列举当前目录下面的所有的子文件和文件夹，同时包含了2个目录(./和../) .1.表示当前目录 ....表示上级目录 cd(change directory)切换当前位于的文件夹 --&gt;切换文件夹之后，最好使用pwd检测当前的文件夹是否发生了变化 cd 指定的文件夹路径 cd 默认情况下只能切换到当前目录下面的子目录 如果想要回到上级目录，应该使用：cd ../ 如果想要回到上上级目录，应该使用：cd ../../ 命令名称 -选项1 -选项2或者命令名称 -选项1选项2 ls -al === ls -a -l 列举当前目录下面的所有的子文件和文件夹，并且显示详细信息，同时包含了2个目录(.和..) ls -l === ls -list === ls --list ls -a === ls -all === ls --all mkdir(make dirctory)创建文件夹 语法格式: mkdir 文件夹名称 默认情况下，只能在当前目录下面创建文件夹 –&gt;可以连续创建多个文件夹：mkdir a1 a2 a3 也可以在指定目录下面创建文件夹：mkdir 指定的文件夹路径/新文件夹名称–&gt;要确保指定的文件夹路径存在 –&gt;执行命令：mkdir app/css 只有当app存在的时候才能创建css文件夹；如果不存在就会创建失败 如果一定要实现在app本身就不存在的时候创建css,就需要通过以下方式：- mkdir app/css -p：首先创建app，然后创建css mkdir 目录1/目录2/目录3 -p--&gt;可以连续创建多级目录，哪怕目录1/目录2都不存在,如果某个目录不存在，先创建该目录，再创建子目录 rmdir(remove directory)只能删除空文件夹 rm删除文件 语法格式：rm 文件路径(不能删除文件路径(即文件夹)) 如果删除的文件路径不存在，那么会报错 不能删除自身，也不能删除父目录（不能含有.和..） 123rm -f 如果说要删除的文件、文件夹不存在，不会显示错误信息rm -r 递归删除(常用于删除非空文件夹)--&gt;这个可以删除文件夹,慎用 (☆☆☆慎用☆☆☆)rm -rf 递归删除指定的文件/文件夹 touch 创建文件语法格式：touch 含有后缀的文件名 –&gt;默认是在当前目录下面创建指定的文件 连续的在当前目录下面创建多个文件 touch 文件夹/文件名：在指定文件夹下面创建指定的文件 cp(copy)复制指定的文件/文件夹 123语法格式：cp 源文件的路径(文件夹+文件名) 新文件的路径(文件夹)复制文件夹：cp 源文件夹路径 新文件夹路径 -r mv(move)移动文件(剪切+粘贴) 12345语法格式：mv 源文件的路径(文件夹+文件名) 新文件的路径(文件夹)移动并重命名：mv 源文件的路径(文件夹+文件名) 新文件的路径(文件夹)+新文件名直接对一个文件重命名：mv 源文件的路径(原文件夹+原文件名) 原文件夹+新文件名 cat 查看文档1cat 路径文档 –&gt;可能乱码,需保持编码一致(一般UTF-8) 任何命令(bash/git)都可以通过–help查看该命令的参数、选项 vi编辑器对一些简单文本文件进行编辑操作 比如一些特殊的文件：ppt/excel/word/图片/xmind都是不能用记事本打开的，也就不能用vi编辑器来进行编辑 123vi 文件路径打开一个窗口，实现对该文件进行编辑 进入编辑模式：i或者a键 退出编辑模式：esc键 如果当前不处于编辑模式，想要实现保存的功能：”:w” ………………….想要实现退出的功能：”:q” …………………想要实现保存并退出的功能：”:wq” --&gt;如果当前位于编辑模式，应该首先退出编辑模式，然后再实现保存or退出的功能 --&gt;如果有内容不需要保存并退出的话，建议：先退出编辑模式，然后命令&quot;:q!&quot; 注意：:!q是没用的 一旦有内容没有保存直接关闭了编辑器窗口，下次的编辑该文件进入错误页面，需要按下d键删除之前的内容]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发环境搭建拓展篇(git)]]></title>
    <url>%2F2016%2F12%2F15%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8B%93%E5%B1%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[​ 上一篇讲到了新浪云应用，现在我们来讲讲里面的一些好用好玩的东西。 ​ 博主会以实践中的过程来讲，目的为了使博主自己对这些有趣的东西加深映象；这也是小白级别的，所以各路大神请绕道或者可以给予更多的点评（博主need you，额..貌似也不会看）。文章里面会更多的讲述博主在微信公众号开发环境搭建的时候遇到了一些有趣的东西和大家分享，对于概念性定义会跳转到百度词条，毕竟此时的博主不能对各种术语进行很好的诠释，并且在文中出现的有偏驳之处，还请看客老爷指正，以免博主以及其他看客老爷们入更深的坑。 SAE全称Sina App Engine（链接地址：http://sinaapp.com/），定义见百度词条。 当时作为微信公众号平台开发搭建的一个URL（服务器地址）接口，好处： 1.免费二级域名，不用环境架构搭建，非常适用于web开发； 2.多版本控制（Git、SVN等），代码部署方便、迭代便捷。 总结下来：无（jian）脑（dan）凶（shi）残（yong）。 GitHubGitHub是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。详见百度词条。 建议大家去注册一个账号尝试着实践实践，还是挺有趣的。和通常我们这些小白对于代码的管理有不同的体验。 使用Git客户端下载Git Bash（window版本 链接：https://git-for-windows.github.io/），定义见百度词条。也可以直接使用CMD。 注意：需要在新浪云应用的创建过程中代码管理必须选择GIT。 然后我们开始来学习Git吧！]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>微信</tag>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发环境搭建]]></title>
    <url>%2F2016%2F12%2F15%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[第一章 申请服务器资源创建新浪云计算应用申请账号我们使用SAE新浪云计算平台作为服务器资源，并且申请PHP环境+MySQL数据库作为程序运行环境。申请地址为：http://www.sinacloud.com/ucenter.html点击进入之后，使用新浪微博账号登录；登录之后，按照提示注册个人信息即可。 创建新应用回到首页，在菜单顶部选择 控制台 ，再选择 云应用SAE ；进入SAE应用列表，点击下侧的 创建应用，这时会弹出提示， 禁止放置违法违规内容，点击 继续创建；开发语言选择PHP，运行环境为 标准环境，语言版本 5.3，代码管理选择 SVN（新浪云支持Git、SVN、代码打包上传三种提交方式，具体请参考：https://www.sinacloud.com/doc/sae/tutorial/code-deploy.html），二级域名自己想一个名字，应用名称可以用系统默认填的，然后点击右方的 创建应用，应用创建成功。并自动跳转到应用列表中，可以看到已经有刚才创建的这个应用。 创建版本点击刚才创建的应用名称，进入应用主页；点击左侧的 应用管理 下面的 代码管理，在代码管理中，选择使用SVN托管的方式。不要使用云空间和Git的方式，跳转到代码管理，点击右侧的“创建版本”，版本号默认为1，点击创建，有时会弹出安全登录，需要输入安全密码，如果不知道或者忘记了，就点里面的找回密码，重新设置一下。验证通过之后，到这里，就成功创建了一个域名URL为 http://***.sinaapp.com/ 的应用了，记住你的这个URL，后面将会用到。 上传代码下述代码index.php是一个微信接口文件，看不懂没有关系，你可以暂时不用弄明白它的意思。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;？phpheader('Content-type:text');define("TOKEN", "weixin");$wechatObj = new wechatCallbackapiTest();if (isset($_GET['echostr'])) &#123; $wechatObj-&gt;valid();&#125;else&#123; $wechatObj-&gt;responseMsg();&#125;class wechatCallbackapiTest&#123; public function valid() &#123; echo Str = _GET["echostr"]; if($this-&gt;checkSignature())&#123; header('content-type:text'); echo $echoStr; exit; &#125; &#125; private function checkSignature() &#123; signature = _GET["signature"]; timestamp = _GET["timestamp"]; nonce = _GET["nonce"]; $token = TOKEN; tmpArr = array(token, timestamp, nonce); sort($tmpArr, SORT_STRING); tmpStr = implode( tmpArr ); tmpStr = sha1( tmpStr ); if( tmpStr == signature )&#123; return true; &#125;else&#123; return false; &#125; &#125; public function responseMsg() &#123; postStr = GLOBALS["HTTP_RAW_POST_DATA"]; if (!empty($postStr))&#123; postObj = simplexml_load_string(postStr, 'SimpleXMLElement', LIBXML_NOCDATA); fromUsername = postObj-&gt;FromUserName; toUsername = postObj-&gt;ToUserName; keyword = trim(postObj-&gt;Content); $time = time(); $textTpl = "&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;FuncFlag&gt;0&lt;/FuncFlag&gt; &lt;/xml&gt;"; if(keyword == "?" || keyword == "？") &#123; $msgType = "text"; $contentStr = date("Y-m-d H:i:s",time()); resultStr = sprintf(textTpl, fromUsername, toUsername, time, msgType, $contentStr); echo $resultStr; &#125; &#125;else&#123; echo ""; exit; &#125; &#125;&#125;?&gt; 我们将使用上述代码与微信公众平台对接。 回到SAE的代码管理界面中；再选择“上传代码包”，点击上传文件，选择index.zip(对index.php打包)文件，点击上传。 上传成功后中间是一个绿色的横条；如果没有绿色的横条，表示上传失败，需要重试（可以考虑在Chrome浏览器下重试一下）。 点击编辑代码按钮，有时候需要输入自己的安全密码，如果不记得了就点击“找回密码”，安全验证成功后继续之前的操作。我们可以看到index.php已经上传成功，双击可以查看编辑里面的代码新浪云应用的创建就成功了。 经测试，有的应用会自动出现一个叫index.html的文件，只需要我们自己上传的index.php和config.yaml文件就可以了。多余的要删除！！！ 第二章 启用开发模式微信公众平台开发模式个人开发者使用测试号个人学习开发建议使用测试号 微信测试号地址：http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login 登录后，在接口配置信息中填写刚才生成的URL地址和Token. URL地址就是上面介绍的云应用的域名地址：http://1.***.applinzi.com/ 或者 http://***.applinzi.com/都可以； Token在程序中固定为 weixin 填写好提交，顶部显示配置成功；如果提示“token验证失败”，多重次几次。 企业开发者并且有订阅号或者服务号微信公众平台地址：https://mp.weixin.qq.com 登录微信公众平台后台，在左侧列表中最下方，找到“ 基本配置 ”，点击进入服务器配置填写框，点击“修改配置”按钮。 此处的URL为上面介绍的云应用的域名；而Token在index.php中定义为weixin；EncodingAESKey则不用填，点击“随机生成”让自动生成一个；消息加解密方式选择“明文模式”，然后点击“提交”按钮。 在弹出的提示框中，点击“确定”；配置修改后，再点击“启用”按钮；询问“是否确定开启服务器配置”，点击“确定”。如果提示“token验证失败”，可以先重次几次，微信服务器有时候不稳定。另外新浪SAE要求进行实名认证，请先上传身份证进行实名认证并通过审核后再试！ 如果还是失败，请先用微信调试器测试一下url和token是否正确(点此查看详细测试方法)。 成功启用后，恭喜，你成功启用开发模式。 自动回复在上面的例子中，实现了一个发送“?”就能回复当前时间的功能。至此，你的微信公众平台账号已经实现自动回复了。 如上操作正确的话，最基础的微信公众号开发搭建算是完成了，接下来更多丰富多彩的公众号开发技术还要等你去实现咯。 如有技术问题以及意见，还请各位看客多多指正分享。 技术参考链接：http://www.cnblogs.com/txw1958/]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>公众号</tag>
        <tag>新浪云SAE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见正则表达式]]></title>
    <url>%2F2016%2F08%2F25%2F%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+ 或 ^[A-Za-z0-9]{4,40} 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+ 或 ^\w{3,20} 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20} 可以输入含有^%&amp;’,;=?\”等字符：%&amp;’,;=?\x22+ 禁止输入含有~的字符：~\x22+123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134一、校验字符的表达式1 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$2 英文和数字：^[A-Za-z0-9]+ 或 ^[A-Za-z0-9]&#123;4,40&#125;3 长度为3-20的所有字符：^.&#123;3,20&#125;$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\w+ 或 ^\w&#123;3,20&#125;9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;11 可以输入含有^%&amp;&apos;,;=?\&quot;等字符：%&amp;&apos;,;=?\x22+12 禁止输入含有~的字符：~\x22+二、数字1 数字：^[0-9]*$2 n位的数字：^\d&#123;n&#125;$3 至少n位的数字：^\d&#123;n,&#125;$4 m-n位的数字：^\d&#123;m,n&#125;$5 零和非零开头的数字：^(0|1-9*)$6 非零开头的最多带两位小数的数字：^(1-9*)+(.[0-9]&#123;1,2&#125;)?$7 带1-2位小数的正数或负数：^(-)?\d+(.\d&#123;1,2&#125;)?$8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\d$ 或 ^(1-9)&#123;1,3&#125; 或 ^\+?[1-9][0-9]*12 非零的负整数：^-1-90-9&quot;$ 或 ^-[1-9]\d$13 非负整数：^\d+ 或 ^[1-9]\d*|014 非正整数：^-[1-9]\d*|0 或 ^((-\d+)|(0+))15 非负浮点数：^\d+(.\d+)? 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|016 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?)) 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|017 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))18 负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d) 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))19 浮点数：^(-?\d+)(.\d+)? 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)三、特殊需求表达式1 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$2 域名：a-zA-Z0-9&#123;0,62&#125;(/.a-zA-Z0-9&#123;0,62&#125;)+/.?3 InternetURL：[a-zA-z]+://\s* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^((\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$6 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;7 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$8 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)? 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^a-zA-Z&#123;4,15&#125;$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).&#123;8,10&#125;$12 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^1-9*$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|1-9*)$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?1-9*)$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$24 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+.x|X[l|L]$26 中文字符的正则表达式：[\u4e00-\u9fa5]27 双字节字符：\x00-\xff (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\S?)&gt;&gt;.?&lt;/\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\s|\s或(^\s)|(\s) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：1-9&#123;4,&#125; (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)33 IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用)34 IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d).)&#123;3&#125;(?:25[0-5]|2[0-4]\d|[01]?\d?\d))]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Reg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2016%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
